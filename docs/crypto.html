<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>EchoBreak - Крипта</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" type="image/png" href="images/favicon.png" />

    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> 
</head>
<body>

<header>
    <a href="index.html" id="logo-link">
        <img src="images/logo.png" alt="EchoBreak Logo" class="logo">
    </a>
    <nav>
        <ul>
            <space></space>
            <li><a href="about.html">О нас</a></li>
            <li><a href="projects.html">Проекты</a></li>
            <li><a href="fanfics.html">Комьюнити</a></li>
            <li><a href="crypto.html" class="active">Крипта</a></li>
        </ul>
    </nav>
</header>

<div class="separator"></div>

<main>
    <!-- <h1>EchoBreak</h1> -->
    <h1>Crypto</h1>
    <h2>For educational purposes only!</h2>

    <div id="xmr-stats">
        <div class="crypto-card">
            <div class="crypto-card-body">
                <div class="balance">
                    <span>Выплачено:</span>
                    <div class="amount" id="xmr-amount">Загрузка...</div>
                    <div class="amount-rub" id="rub-amount"></div>
                </div>
                <div class="currency-logo">
                    <img src="images/monero-logo.png" alt="Monero Logo">
                </div>
            </div>
        </div>
    </div>

    <!-- Chart Container -->
    <div class="chart-container" style="width: 90%; max-width: 600px; margin: 40px auto;">
        <canvas id="xmrRubChart"></canvas>
    </div>

    <div id="trading-bot">
        <div class="crypto-card">
            <div class="crypto-card-body">
                <div class="balance">
                    <span>Trading Bot (Alpha ver.):</span>
                    <p id="bot-signal">Loading...</p>
                    <div id="bot-info">
                        <small>Price: <span id="current-price">—</span> ₽</small><br>
                        <small>Strategy: SMA Crossover (10 &amp; 20 days)</small>
                    </div>
                </div>
                <div class="currency-logo">
                    <img src="images/nvidia-logo.png" alt="NVDA Logo">
                </div>
            </div>
        </div>
    </div>
</main>

<footer>
    <p>EchoBreak, 2025</p>
</footer>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const xmrAmount = document.getElementById('xmr-amount');
        const rubAmount = document.getElementById('rub-amount');

        const WALLET_ADDRESS = '42u3Aeoqq53Y8bKGT7RdawhtcS9AqYuKEDwwYL4BiS5s34964uaJU2zWB7miadNEBWCjcMXtMjcsa6boEZmpaeTV4ESEqpU';

        // Fetch wallet stats
        fetch(`https://api.moneroocean.stream/miner/${WALLET_ADDRESS}/stats`) 
            .then(response => {
                if (!response.ok) throw new Error('Wallet fetch error');
                return response.json();
            })
            .then(data => {
                const totalDue = parseFloat(data.amtPaid / 1000000000000 || 0).toFixed(6);

                // Fetch current price
                return fetch('https://api.coingecko.com/api/v3/simple/price?ids=monero&vs_currencies=rub')
                    .then(res => {
                        if (!res.ok) throw new Error('Price fetch error');
                        return res.json();
                    })
                    .then(priceData => {
                        const xmrPriceRub = priceData.monero.rub;
                        const rubValue = (parseFloat(totalDue) * xmrPriceRub).toFixed(2);
                        xmrAmount.textContent = `${totalDue} XMR`;
                        rubAmount.textContent = `${rubValue} ₽`;

                        // Now fetch historical data for the chart
                        return fetch('https://api.coingecko.com/api/v3/coins/monero/market_chart?vs_currency=rub&days=30')
                            .then(res => {
                                if (!res.ok) throw new Error('Historical fetch error');
                                return res.json();
                            });
                    })
                    .then(chartData => {
                        const prices = chartData.prices.map(p => p[1]); // Extract price values
                        const timestamps = chartData.prices.map(p => p[0]); // Extract timestamps

                        // Sample data to reduce the number of points
                        const sampledPrices = [];
                        const sampledTimestamps = [];
                        const step = Math.ceil(timestamps.length / 30); // Show approximately 30 points

                        for (let i = 0; i < timestamps.length; i += step) {
                            sampledPrices.push(prices[i]);
                            sampledTimestamps.push(timestamps[i]);
                        }

                        // Convert timestamps to readable dates
                        const labels = sampledTimestamps.map(timestamp => {
                            const date = new Date(timestamp);
                            return date.toISOString().split('T')[0]; // Format as YYYY-MM-DD
                        });

                        drawChart(labels, sampledPrices);
                    })
                    .catch(chartError => {
                        console.warn("Failed to load real chart data:", chartError.message);
                        drawFallbackChart();
                    });
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                xmrAmount.textContent = '—';
                rubAmount.textContent = '—';
                drawFallbackChart();
            });
    });

    function drawChart(labels, data) {
        const ctx = document.getElementById('xmrRubChart').getContext('2d');
        renderChart(labels, data);
    }

    function drawFallbackChart() {
        const days = Array.from({ length: 30 }, (_, i) => `Day ${i + 1}`);
        const xmrToRubData = [
            2800, 2850, 2830, 2780, 2810, 2890, 2900, 2950, 3000, 3020,
            3010, 3030, 3050, 3070, 3100, 3120, 3110, 3130, 3150, 3170,
            3190, 3210, 3200, 3220, 3250, 3270, 3260, 3280, 3300, 3320
        ];
        renderChart(days, xmrToRubData);
    }

    function renderChart(labels, data) {
        const ctx = document.getElementById('xmrRubChart').getContext('2d');

        // Determine line color based on trend
        const firstPrice = data[0];
        const lastPrice = data[data.length - 1];
        const borderColor = lastPrice > firstPrice ? '#00ff00' : '#ff0000'; // Green for up, Red for down 

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'XMR to RUB (Last 30 Days)',
                    data: data,
                    borderColor: borderColor,
                    backgroundColor: 'rgba(210, 83, 84, 0.1)',
                    tension: 0.3,
                    fill: true,
                    pointRadius: 2,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: false,
                        ticks: {
                            color: '#fff'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#fff',
                            callback: function (value, index, values) {
                                // Show only every 5th label to avoid overcrowding
                                return index % 3 === 0 ? value : '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#fff'
                        }
                    }
                }
            }
        });
    }

    function runTradingBot() {
        const botSignal = document.getElementById('bot-signal');
        const currentPriceElem = document.getElementById('current-price');
        const botInfo = document.getElementById('bot-info');
    
        const SYMBOL = 'NVDA';
        const FMP_API_KEY = '2bxb0il75hhAFMqNlppJ3yevZo0J7xMI'; // Get at https://financialmodelingprep.com
        const STOCK_URL = `https://financialmodelingprep.com/api/v3/historical-price-full/${SYMBOL}?timeseries=30&apikey=${FMP_API_KEY}`;
        const EXCHANGE_URL = 'https://api.exchangerate-api.com/v4/latest/USD';
    
        Promise.all([
            fetch(STOCK_URL).then(res => res.json()),
            fetch(EXCHANGE_URL).then(res => res.json())
        ])
        .then(([stockData, exchangeData]) => {
            const usdToRub = exchangeData.rates.RUB;
    
            // Extract last 30 days of closing prices (for RSI & EMA)
            const closes = stockData.historical
                .slice(0, 30)
                .map(day => parseFloat(day.close) * usdToRub)
                .reverse(); // [0] = oldest, [n] = newest
    
            if (closes.length < 14) {
                botSignal.textContent = "Not enough data";
                return;
            }
    
            // === 1. Calculate EMA12 and EMA26 (for MACD-style crossover) ===
            const ema12 = calculateEMA(closes, 12);
            const ema26 = calculateEMA(closes, 26);
            const price = closes[closes.length - 1];
            currentPriceElem.textContent = price.toFixed(2);
    
            // === 2. Calculate RSI(14) ===
            const rsi = calculateRSI(closes, 14);
            const rsiValue = rsi[rsi.length - 1];
    
            // === 3. Generate Signal ===
            let signal = '';
            let reason = '';
    
            const emaBullish = ema12[ema12.length - 1] > ema26[ema26.length - 1];
            const emaPrevBullish = ema12[ema12.length - 2] > ema26[ema26.length - 2];
            const emaCrossUp = !emaPrevBullish && emaBullish;
            const emaCrossDown = emaPrevBullish && !emaBullish;
    
            if (emaCrossUp && rsiValue < 70) {
                signal = '🟢 BUY';
                reason = 'EMA12/26 Cross Up + RSI < 70';
            } else if (emaCrossDown && rsiValue > 30) {
                signal = '🔴 SELL';
                reason = 'EMA12/26 Cross Down + RSI > 30';
            } else if (emaBullish && rsiValue < 60) {
                signal = '🟡 HOLD (Uptrend)';
                reason = 'EMA Bullish + RSI Not Overbought';
            } else if (!emaBullish && rsiValue > 40) {
                signal = '🟡 WATCH (Downtrend)';
                reason = 'EMA Bearish + RSI Not Oversold';
            } else {
                signal = '🔵 NEUTRAL';
                reason = 'Waiting for confirmation';
            }
    
            botSignal.innerHTML = `<strong>${signal}</strong>`;
            botInfo.innerHTML = `
                <small>Price: ${price.toFixed(2)} ₽</small><br>
                <small>RSI(14): ${rsiValue.toFixed(2)}</small><br>
                <small>Trend: ${emaBullish ? 'Bullish' : 'Bearish'}</small><br>
                <small><em>${reason}</em></small>
            `;
    
            // === 4. Backtest: Simulate 1000 RUB invested 20 days ago ===
            const initialInvestment = 1000;
            const daysAgo = Math.min(20, closes.length - 1);
            const buyPrice = closes[closes.length - 1 - daysAgo]; // Price 20 days ago
            const shares = initialInvestment / buyPrice;
            const currentValue = shares * price;
            const change = ((currentValue - initialInvestment) / initialInvestment * 100).toFixed(2);
            const trendEmoji = change > 0 ? '🟢' : '🔴';
            const absChange = Math.abs(change);
    
            botInfo.innerHTML += `<br><small>Simulated return (${daysAgo}d): ${trendEmoji} ${absChange}%</small>`;
    
        })
        .catch(err => {
            console.error("Bot error:", err);
            botSignal.textContent = "Error fetching data";
            botInfo.innerHTML = "<small>Could not load market data.</small>";
        });
    }
    
    // Run the bot after DOM loads
    runTradingBot();

    // === EMA Calculator ===
    function calculateEMA(prices, period) {
        const k = 2 / (period + 1);
        const ema = [];
        let sum = 0;
    
        // First EMA = SMA of first `period` values
        for (let i = 0; i < period; i++) {
            sum += prices[i];
        }
        let currentEMA = sum / period;
        ema.push(currentEMA);
    
        // Rest: EMA = Priceₜ × k + EMAₜ₋₁ × (1 - k)
        for (let i = period; i < prices.length; i++) {
            currentEMA = prices[i] * k + currentEMA * (1 - k);
            ema.push(currentEMA);
        }
    
        return ema;
    }
    
    // === RSI Calculator (14-period) ===
    function calculateRSI(prices, period) {
        const gains = [];
        const losses = [];
    
        for (let i = 1; i < prices.length; i++) {
            const diff = prices[i] - prices[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? Math.abs(diff) : 0);
        }
    
        const rsi = [];
        for (let i = period; i < gains.length; i++) {
            const avgGain = gains.slice(i - period, i).reduce((a, b) => a + b, 0) / period;
            const avgLoss = losses.slice(i - period, i).reduce((a, b) => a + b, 0) / period;
    
            if (avgLoss === 0) {
                rsi.push(100); // Avoid divide by zero
            } else {
                const rs = avgGain / avgLoss;
                rsi.push(100 - (100 / (1 + rs)));
            }
        }
    
        return rsi;
    }
</script>

</body>
</html>
